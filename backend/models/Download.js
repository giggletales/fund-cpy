const mongoose = require('mongoose');

const downloadSchema = new mongoose.Schema({
  userId: { 
    type: mongoose.Schema.Types.ObjectId, 
    ref: 'User', 
    required: true,
    index: true
  },
  
  accountId: { 
    type: mongoose.Schema.Types.ObjectId, 
    ref: 'TradingAccount'
  },
  
  transactionId: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Transaction'
  },
  
  documentType: {
    type: String,
    enum: [
      'WELCOME_CERTIFICATE',
      'PURCHASE_INVOICE',
      'PURCHASE_RECEIPT', 
      'CHALLENGE_STARTED_CERTIFICATE',
      'CHALLENGE_PASSED_CERTIFICATE',
      'FUNDED_TRADER_CERTIFICATE',
      'FIRST_PAYOUT_CERTIFICATE',
      'PAYOUT_RECEIPT',
      'MONTHLY_STATEMENT',
      'TAX_DOCUMENT'
    ],
    required: true
  },
  
  documentInfo: {
    title: { type: String, required: true },
    description: String,
    documentNumber: { type: String, required: true, unique: true },
    issueDate: { type: Date, default: Date.now }
  },
  
  fileInfo: {
    fileName: String,
    fileUrl: String,
    fileSize: Number,
    fileFormat: { type: String, default: 'PDF' }
  },
  
  certificateData: {
    traderName: String,
    achievementType: String,
    achievementDate: Date,
    challengeType: String,
    accountSize: Number,
    profitEarned: Number,
    profitPercentage: Number,
    tradingStats: {
      totalTrades: Number,
      winRate: Number,
      profitFactor: Number,
      bestTrade: Number,
      consistency: Number
    },
    certificateNumber: String
  },
  
  invoiceData: {
    invoiceNumber: String,
    amount: Number,
    currency: String,
    paymentMethod: String,
    items: [{
      description: String,
      amount: Number
    }],
    discount: Number,
    tax: Number,
    total: Number,
    billingAddress: mongoose.Schema.Types.Mixed
  },
  
  payoutData: {
    payoutId: String,
    period: {
      start: Date,
      end: Date,
      cycle: String
    },
    profitEarned: Number,
    payoutPercentage: Number,
    payoutAmount: Number,
    paymentMethod: String,
    destination: String,
    reference: String
  },
  
  status: {
    type: String,
    enum: ['generating', 'ready', 'failed'],
    default: 'generating'
  },
  
  autoGenerated: { type: Boolean, default: false },
  generatedAt: Date,
  generationError: String,
  
  downloadCount: { type: Number, default: 0 },
  lastDownloadedAt: Date,
  
  createdAt: { type: Date, default: Date.now }
});

downloadSchema.pre('save', async function(next) {
  if (!this.documentInfo.documentNumber) {
    const prefix = this.documentType.split('_')[0].substring(0, 3).toUpperCase();
    const timestamp = Date.now();
    const random = Math.random().toString(36).substring(2, 8).toUpperCase();
    this.documentInfo.documentNumber = `${prefix}-${timestamp}-${random}`;
  }
  next();
});

module.exports = mongoose.model('Download', downloadSchema);
